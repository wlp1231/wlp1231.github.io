<!-- build time:Fri Aug 15 2025 10:49:47 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="随笔" href="https://wlp1231.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="随笔" href="https://wlp1231.cn/atom.xml"><link rel="alternate" type="application/json" title="随笔" href="https://wlp1231.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="note,教程"><link rel="canonical" href="https://wlp1231.cn/the-tutorial/note/socket%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"><title>socket 通信机制详解 - note - 教程 | wlp-blog = 随笔</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">socket 通信机制详解</h1><div class="meta"><span class="item" title="创建时间：2023-01-11 13:38:35"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-01-11T13:38:35+08:00">2023-01-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.5k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">wlp-blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/252916b13cdf9428f497f9c3da8b2aa7.md.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/86a28095f8e05aa07544b454ec6f01f6.md.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/2f015bf5c14d8b24eba440ef80422b8d.md.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/d757e4c9c546cd7dba16ee5e23dc2d9d.md.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/43d42ed802c921c4e8af87cbe3ff2906.md.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/4ae00b1d55fc55227c12fbe35843514e.md.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/the-tutorial/" itemprop="item" rel="index" title="分类于 教程"><span itemprop="name">教程</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/the-tutorial/note/" itemprop="item" rel="index" title="分类于 note"><span itemprop="name">note</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wlp1231.cn/the-tutorial/note/socket%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="wlp"><meta itemprop="description" content=", 个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="随笔"></span><div class="body md" itemprop="articleBody"><h1 id="socket通信机制详解"><a class="anchor" href="#socket通信机制详解">#</a> socket 通信机制详解</h1><p>我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与 web 服务器通信的？当你用 <code>QQ</code> 聊天时， <code>QQ</code> 进程怎么与服务器或你好友所在的 <code>QQ</code> 进程通信？这些都得靠 socket？那什么是 socket？socket 的类型有哪些？还有 socket 的基本函数，这些都是本文想介绍的。本文的主要内容如下：</p><ul><li>1、网络中进程之间如何通信？</li><li>2、Socket 是什么？</li><li>3、socket 的基本操作<ul><li>3.1、socket () 函数</li><li>3.2、bind () 函数</li><li>3.3、listen ()、connect () 函数</li><li>3.4、accept () 函数</li><li>3.5、read ()、write () 函数等</li><li>3.6、close () 函数</li></ul></li><li>4、socket 中 TCP 的三次握手建立连接详解</li><li>5、socket 中 TCP 的四次握手释放连接详解</li><li>6、一个例子（实践一下）</li><li>7、留下一个问题，欢迎大家回帖回答！！！</li></ul><h1 id="1-网络中进程之间如何通信"><a class="anchor" href="#1-网络中进程之间如何通信">#</a> 1、网络中进程之间如何通信？</h1><p>本地的进程间通信（ <code>IPC</code> ）有很多种方式，但可以总结为下面 4 类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（ <code>Solaris</code> 门和 <code>Sun RPC</code> ）</li></ul><p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程 <code>PID</code> 唯一标识一个进程，但是在网络中这是行不通的。其实 <code>TCP/IP</code> 协议族已经帮我们解决了这个问题，网络层的 “ <code>**ip地址**”</code> 可以唯一标识网络中的主机，而传输层的 “<strong>协议 + 端口</strong>” 可以唯一标识主机中的应用程序（进程）。这样利用三元组（ <code>ip</code> 地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><p>使用 <code>TCP/IP</code> 协议的应用程序通常采用应用编程接口：UNIX BSD 的套接字（socket）和 UNIX System V 的 <code>TLI</code> 已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用 socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说 “一切皆 socket”。</p><h1 id="2-什么是socket"><a class="anchor" href="#2-什么是socket">#</a> 2、什么是 Socket？</h1><p>上面我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢？socket 起源于 Unix，而 Unix/Linux 基本哲学之一就是 “一切皆文件”，都可以用 “打开 open –&gt; 读写 write/read –&gt; 关闭 close” 模式来操作。我的理解就是 Socket 就是该模式的一个实现，socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作（读 / 写 IO、打开、关闭），这些函数我们在后面进行介绍。</p><blockquote><h3 id="socket一词的起源"><a class="anchor" href="#socket一词的起源">#</a> socket 一词的起源</h3><p>在组网领域的首次使用是在 1970 年 2 月 12 日发布的文献<span class="exturl" data-url="aHR0cDovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9yZmMzMy8="> IETF RFC33</span> 中发现的，撰写者为 Stephen Carr、Steve Crocker 和 <code>Vint</code> Cerf。根据美国计算机历史博物馆的记载， <code>Croker</code> 写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。” 计算机历史博物馆补充道：“这比 BSD 的套接字接口定义早了大约 12 年。”</p></blockquote><h1 id="3-socket的基本操作"><a class="anchor" href="#3-socket的基本操作">#</a> 3、socket 的基本操作</h1><p>既然 socket 是 “open—write/read—close” 模式的一种实现，那么 socket 就提供了这些操作对应的函数接口。下面以 TCP 为例，介绍几个基本的 socket 接口函数。</p><h2 id="31-socket函数"><a class="anchor" href="#31-socket函数">#</a> 3.1、socket () 函数</h2><pre><code>int socket(int domain, int type, int protocol);
</code></pre><p>socket 函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而 ****socket ()**** 用于创建一个 socket 描述符（socket descriptor），它唯一标识一个 socket。这个 socket 描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给 fopen 的传入不同参数值，以打开不同的文件。创建 socket 的时候，也可以指定不同的参数创建不同的 socket 描述符，socket 函数的三个参数分别为：</p><ul><li>domain：即协议域，又称为协议族（family）。常用的协议族有， <code>AF_INET、AF_INET6、AF_LOCAL</code> （或称 AF_UNIX，Unix 域 socket）、AF_ROUTE 等等。协议族决定了 socket 的地址类型，在通信中必须采用对应的地址，如 <code>AF_INET</code> 决定了要用 <code>ipv4</code> 地址（32 位的）与端口号（16 位的）的组合、AF_UNIX 决定了要用一个绝对路径名作为地址。</li><li>type：指定 socket 类型。常用的 socket 类型有， <code>SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET</code> 等等（socket 的类型有哪些？）。</li><li>protocol：故名思意，就是指定协议。常用的协议有， <code>IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC</code> 等，它们分别对应 TCP 传输协议、 <code>UDP</code> 传输协议、 <code>STCP</code> 传输协议、 <code>TIPC</code> 传输协议（这个协议我将会单独开篇讨论！）。</li></ul><p>注意：并不是上面的 type 和 protocol 可以随意组合的，如 SOCK_STREAM 不可以跟 <code>IPPROTO_UDP</code> 组合。当 protocol 为 0 时，会自动选择 type 类型对应的默认协议。</p><p>当我们调用 ****socket**** 创建一个 socket 时，返回的 socket 描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用 bind () 函数，否则就当调用 connect ()、listen () 时系统会自动随机分配一个端口。</p><h2 id="32-bind函数"><a class="anchor" href="#32-bind函数">#</a> 3.2、bind () 函数</h2><p>正如上面所说 bind () 函数把一个地址族中的特定地址赋给 socket。例如对应 <code>AF_INET</code> 、 <code>AF_INET6</code> 就是把一个 <code>ipv4</code> 或 <code>ipv6</code> 地址和端口号组合赋给 socket。</p><pre><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre><p>函数的三个参数分别为：</p><ul><li><p>sockfd：即 socket 描述字，它是通过 socket () 函数创建了，唯一标识一个 socket。bind () 函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：一个</p><p>const</p><p>struct</p><p>sockaddr * 指针，指向要绑定给 sockfd 的协议地址。这个地址结构根据地址创建 socket 时的地址协议族的不同而不同，如 ipv4 对应的是：</p><pre><code>struct sockaddr_in &#123;
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order */
    struct in_addr sin_addr;   /* internet address */
&#125;;

/* Internet address. */
struct in_addr &#123;
    uint32_t       s_addr;     /* address in network byte order */
&#125;;
</code></pre><p>ipv6 对应的是：</p><pre><code>struct sockaddr_in6 &#123; 
    sa_family_t     sin6_family;   /* AF_INET6 */ 
    in_port_t       sin6_port;     /* port number */ 
    uint32_t        sin6_flowinfo; /* IPv6 flow information */ 
    struct in6_addr sin6_addr;     /* IPv6 address */ 
    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ 
&#125;;

struct in6_addr &#123; 
    unsigned char   s6_addr[16];   /* IPv6 address */ 
&#125;;
</code></pre><p>Unix 域对应的是：</p><pre><code>#define UNIX_PATH_MAX    108

struct sockaddr_un &#123; 
    sa_family_t sun_family;               /* AF_UNIX */ 
    char        sun_path[UNIX_PATH_MAX];  /* pathname */ 
&#125;;
</code></pre></li><li><p>addrlen：对应的是地址的长度。</p></li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如 ip 地址 + 端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的 ip 地址组合。这就是为什么通常服务器端在 listen 之前会调用 bind ()，而客户端就不会调用，而是在 connect () 时由系统随机生成一个。</p><h3 id="网络字节序与主机字节序"><a class="anchor" href="#网络字节序与主机字节序">#</a> 网络字节序与主机字节序</h3><blockquote><p>**** 主机字节序 **** 就是我们平常说的大端和小端模式：不同的 CPU 有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的 Big- <code>Endian</code> 和 <code>Little-Endian</code> 的定义如下：</p><p>a) <code>Little-Endian</code> 就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p><p>b) <code>Big-Endian</code> 就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p><em><strong>* 网络字节序 *</strong></em>：4 个字节的 32 bit 值以下面的次序传输：首先是 <code>0～7bit</code> ，其次 <code>8～15bit</code> ，然后 <code>16～23bit</code> ，最后是 <code>24~31bit</code> 。这种传输次序称作大端字节序。** 由于 <code>TCP/IP</code> 首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。** 字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p><p>所以：在将一个地址绑定到 socket 的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是 <code>Big-Endian</code> 由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给 socket。</p></blockquote><h2 id="33-listen-connect函数"><a class="anchor" href="#33-listen-connect函数">#</a> 3.3、listen ()、connect () 函数</h2><p>如果作为一个服务器，在调用 socket ()、bind () 之后就会调用 listen () 来监听这个 socket，如果客户端这时调用 connect () 发出连接请求，服务器端就会接收到这个请求。</p><pre><code>int listen(int sockfd, int backlog);
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre><p>listen 函数的第一个参数即为要监听的 socket 描述字，第二个参数为相应 socket 可以排队的最大连接个数。socket () 函数创建的 socket 默认是一个主动类型的，listen 函数将 socket 变为被动类型的，等待客户的连接请求。</p><p>connect 函数的第一个参数即为客户端的 socket 描述字，第二参数为服务器的 socket 地址，第三个参数为 socket 地址的长度。客户端通过调用 connect 函数来建立与 TCP 服务器的连接。</p><h2 id="34-accept函数"><a class="anchor" href="#34-accept函数">#</a> 3.4、accept () 函数</h2><p>TCP 服务器端依次调用 socket ()、bind ()、listen () 之后，就会监听指定的 socket 地址了。TCP 客户端依次调用 socket ()、connect () 之后就想 TCP 服务器发送了一个连接请求。TCP 服务器监听到这个请求之后，就会调用 accept () 函数取接收请求，这样连接就建立好了。之后就可以开始网络 I/O 操作了，即类同于普通文件的读写 I/O 操作。</p><pre><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre><p>accept 函数的第一个参数为服务器的 socket 描述字，第二个参数为指向 struct sockaddr * 的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果 accpet 成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的 TCP 连接。</p><p>注意：accept 的第一个参数为服务器的 socket 描述字，是服务器开始调用 socket () 函数生成的，称为监听 socket 描述字；而 accept 函数返回的是已连接的 socket 描述字。一个服务器通常通常仅仅只创建一个监听 socket 描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接 socket 描述字，当服务器完成了对某个客户的服务，相应的已连接 socket 描述字就被关闭。</p><h2 id="35-read-write等函数"><a class="anchor" href="#35-read-write等函数">#</a> 3.5、read ()、write () 等函数</h2><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络 I/O 进行读写操作了，即实现了网咯中不同进程之间的通信！网络 I/O 操作有下面几组：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>我推荐使用 recvmsg ()/sendmsg () 函数，这两个函数是最通用的 I/O 函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：</p><pre><code>       #include &lt;unistd.h&gt;

       ssize_t read(int fd, void *buf, size_t count);
       ssize_t write(int fd, const void *buf, size_t count);

       #include &lt;sys/types.h&gt;
       #include &lt;sys/socket.h&gt;

       ssize_t send(int sockfd, const void *buf, size_t len, int flags);
       ssize_t recv(int sockfd, void *buf, size_t len, int flags);

       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);
       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);

       ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
       ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
</code></pre><p>read 函数是负责从 <code>fd</code> 中读取内容。当读成功时，read 返回实际所读的字节数，如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。如果错误为 <code>EINTR</code> 说明读是由中断引起的，如果是 <code>ECONNREST</code> 表示网络连接出了问题。</p><p>write 函数将 <code>buf</code> 中的 <code>nbytes</code> 字节内容写入文件描述符 <code>fd</code> . 成功时返回写的字节数。失败时返回 - 1，并设置 <code>errno</code> 变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1) write 的返回值大于 0，表示写了部分或者是全部的数据。2) 返回的值小于 0，此时出现了错误。我们要根据错误类型来处理。如果错误为 <code>EINTR</code> 表示在写的时候出现了中断错误。如果为 <code>EPIPE</code> 表示网络连接出现了问题 (对方已经关闭了连接)。</p><p>其它的我就不一一介绍这几对 I/O 函数了，具体参见 man 文档或者 baidu、Google，下面的例子中将使用到 send/recv。</p><h2 id="36-close函数"><a class="anchor" href="#36-close函数">#</a> 3.6、close () 函数</h2><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的 socket 描述字，好比操作完打开的文件要调用 fclose 关闭打开的文件。</p><pre><code>#include &lt;unistd.h&gt;
int close(int fd);
</code></pre><p>close 一个 TCP socket 的缺省行为时把该 socket 标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为 read 或 write 的第一个参数。</p><p>注意：close 操作只是使相应 socket 描述字的引用计数 - 1，只有当引用计数为 0 的时候，才会触发 TCP 客户端向服务器发送终止连接请求。</p><h1 id="4-socket中tcp的三次握手建立连接详解"><a class="anchor" href="#4-socket中tcp的三次握手建立连接详解">#</a> 4、socket 中 TCP 的三次握手建立连接详解</h1><p>我们知道 tcp 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个 SYN J</li><li>服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 <code>ACK J+1</code></li><li>客户端再想服务器发一个确认 <code>ACK K+1</code></li></ul><p>只有就完了三次握手，但是这个三次握手发生在 socket 的那几个函数中呢？请看下图：</p><p><a target="_blank" rel="noopener" href="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png"><img data-src="https://wlp1231-1316469392.cos.ap-chongqing.myqcloud.com/bolg/201012122157476286.png" alt="image"></a></p><p>图 1、socket 中发送的 TCP 三次握手</p><p>从图中可以看出，当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ， <code>ACK J+1</code> ，这时 accept 进入阻塞状态；客户端收到服务器的 SYN K ， <code>ACK J+1</code> 之后，这时 connect 返回，并对 SYN K 进行确认；服务器收到 <code>ACK K+1</code> 时，accept 返回，至此三次握手完毕，连接建立。</p><blockquote><p>总结：客户端的 connect 在三次握手的第二个次返回，而服务器端的 accept 在三次握手的第三次返回。</p></blockquote><h1 id="5-socket中tcp的四次握手释放连接详解"><a class="anchor" href="#5-socket中tcp的四次握手释放连接详解">#</a> 5、socket 中 TCP 的四次握手释放连接详解</h1><p>上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：</p><p><a target="_blank" rel="noopener" href="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png"><img data-src="https://wlp1231-1316469392.cos.ap-chongqing.myqcloud.com/bolg/201012122157494693.png" alt="image"></a></p><p>图 2、socket 中发送的 TCP 四次握手</p><p>图示过程如下：</p><ul><li>某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；</li><li>另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；</li><li>接收到这个 FIN 的源发送端 TCP 对它进行确认。</li></ul><p>这样每个方向上都有一个 <code>FIN</code> 和 <code>ACK</code> 。</p><p>jio</p><div class="tags"><a href="/tags/note/" rel="tag"><i class="ic i-tag"></i> note</a> <a href="/tags/%E6%95%99%E7%A8%8B/" rel="tag"><i class="ic i-tag"></i> 教程</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-04-12 00:45:27" itemprop="dateModified" datetime="2023-04-12T00:45:27+08:00">2023-04-12</time> </span><span id="the-tutorial/note/socket通信机制详解/" class="item leancloud_visitors" data-flag-title="socket 通信机制详解" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>wlp <i class="ic i-at"><em>@</em></i>随笔</li><li class="link"><strong>本文链接：</strong> <a href="https://wlp1231.cn/the-tutorial/note/socket%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" title="socket 通信机制详解">https://wlp1231.cn/the-tutorial/note/socket通信机制详解/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/the-tutorial/hexo/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;d757e4c9c546cd7dba16ee5e23dc2d9d.md.jpg" title="博客搭建教程"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> hexo</span><h3>博客搭建教程</h3></a></div><div class="item right"><a href="/the-tutorial/programming/socket-2/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;50d682207f8e6513884d523e2e0895f7.md.jpg" title="socket-2"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 编程</span><h3>socket-2</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#socket%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">socket 通信机制详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">2.</span> <span class="toc-text">1、网络中进程之间如何通信？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFsocket"><span class="toc-number">3.</span> <span class="toc-text">2、什么是 Socket？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E4%B8%80%E8%AF%8D%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="toc-number">3.0.1.</span> <span class="toc-text">socket 一词的起源</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#3-socket%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">3、socket 的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-socket%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">3.1、socket () 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-bind%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">3.2、bind () 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">网络字节序与主机字节序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-listen-connect%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">3.3、listen ()、connect () 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-accept%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">3.4、accept () 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-read-write%E7%AD%89%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">3.5、read ()、write () 等函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-close%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">3.6、close () 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-socket%E4%B8%ADtcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">4、socket 中 TCP 的三次握手建立连接详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-socket%E4%B8%ADtcp%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">5、socket 中 TCP 的四次握手释放连接详解</span></a></li></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/the-tutorial/note/socket%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="socket通信机制详解">socket通信机制详解</a></li><li><a href="/the-tutorial/note/idea%20%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="bookmark" title="小知识">小知识</a></li><li><a href="/the-tutorial/note/%E7%AE%97%E6%B3%95/" rel="bookmark" title="算法">算法</a></li><li><a href="/the-tutorial/note/oj%E5%88%A4%E9%A2%98%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="OJ 判题">OJ 判题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="wlp" data-src="/images/avatar.jpg"><p class="name" itemprop="name">wlp</p><div class="description" itemprop="description">个人博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">20</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">9</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">11</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dscDEyMzE=" title="https:&#x2F;&#x2F;github.com&#x2F;wlp1231"><i class="ic i-github"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/the-tutorial/hexo/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/the-tutorial/programming/socket-2/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/the-tutorial/" title="分类于 教程">教程</a> <i class="ic i-angle-right"></i> <a href="/categories/the-tutorial/programming/" title="分类于 编程">编程</a></div><span><a href="/the-tutorial/programming/socket-1/" title="socket-1">socket-1</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ROS/" title="分类于 ROS">ROS</a> <i class="ic i-angle-right"></i> <a href="/categories/ROS/Ubuntu/" title="分类于 Ubuntu">Ubuntu</a></div><span><a href="/ROS/Ubuntu/Clash%E6%95%99%E7%A8%8B/" title="Clash教程">Clash教程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/embedded/" title="分类于 嵌入式">嵌入式</a> <i class="ic i-angle-right"></i> <a href="/categories/embedded/esp32/" title="分类于 esp32">esp32</a></div><span><a href="/embedded/esp32/ESP32-S3/" title="ESP32-S3">ESP32-S3</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/the-tutorial/" title="分类于 教程">教程</a> <i class="ic i-angle-right"></i> <a href="/categories/the-tutorial/programming/" title="分类于 编程">编程</a></div><span><a href="/the-tutorial/programming/socket-2/" title="socket-2">socket-2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/the-tutorial/" title="分类于 教程">教程</a> <i class="ic i-angle-right"></i> <a href="/categories/the-tutorial/note/" title="分类于 note">note</a></div><span><a href="/the-tutorial/note/oj%E5%88%A4%E9%A2%98%E7%B3%BB%E7%BB%9F/" title="OJ 判题">OJ 判题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/the-tutorial/" title="分类于 教程">教程</a> <i class="ic i-angle-right"></i> <a href="/categories/the-tutorial/programming/" title="分类于 编程">编程</a></div><span><a href="/the-tutorial/programming/vscode%20c++%20%E9%85%8D%E7%BD%AE%20Windows/" title="vscode c++ 配置 Windows">vscode c++ 配置 Windows</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/the-tutorial/" title="分类于 教程">教程</a> <i class="ic i-angle-right"></i> <a href="/categories/the-tutorial/hexo/" title="分类于 hexo">hexo</a></div><span><a href="/the-tutorial/hexo/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" title="博客搭建教程">博客搭建教程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/the-tutorial/" title="分类于 教程">教程</a> <i class="ic i-angle-right"></i> <a href="/categories/the-tutorial/note/" title="分类于 note">note</a></div><span><a href="/the-tutorial/note/%E7%AE%97%E6%B3%95/" title="算法">算法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ROS/" title="分类于 ROS">ROS</a> <i class="ic i-angle-right"></i> <a href="/categories/ROS/Ubuntu/" title="分类于 Ubuntu">Ubuntu</a></div><span><a href="/ROS/Ubuntu/%E5%8F%8C%E7%9B%AET265%E4%BD%BF%E7%94%A8/" title="双目T265使用">双目T265使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ROS/" title="分类于 ROS">ROS</a> <i class="ic i-angle-right"></i> <a href="/categories/ROS/Ubuntu/" title="分类于 Ubuntu">Ubuntu</a></div><span><a href="/ROS/Ubuntu/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F/" title="机器人仿真">机器人仿真</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">wlp @ wlp-blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">84k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:16</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"the-tutorial/note/socket通信机制详解/",favicon:{show:"欢迎回来",hide:"再见"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->